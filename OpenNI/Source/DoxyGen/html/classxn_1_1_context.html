<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenNI 1.5.4: xn::Context Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexn.html">xn</a></li><li class="navelem"><a class="el" href="classxn_1_1_context.html">Context</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classxn_1_1_context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xn::Context Class Reference<div class="ingroups"><a class="el" href="group__cppref.html">C++ Reference to Application Programmer Interface (API)</a> &raquo; <a class="el" href="group__cppref__graph__mgmt.html">Managing the Production Graph</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_xn_cpp_wrapper_8h_source.html">XnCppWrapper.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7f2fb2123f2e753d0c71d7c7aa9e9479"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a7f2fb2123f2e753d0c71d7c7aa9e9479">NodeCreationHandler</a>) (<a class="el" href="classxn_1_1_context.html">Context</a> &amp;context, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;createdNode, void *pCookie)</td></tr>
<tr class="separator:a7f2fb2123f2e753d0c71d7c7aa9e9479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18159f642692e98261f3265533ef38e0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a18159f642692e98261f3265533ef38e0">NodeDestructionHandler</a>) (<a class="el" href="classxn_1_1_context.html">Context</a> &amp;context, const XnChar *strDestroyedNodeName, void *pCookie)</td></tr>
<tr class="separator:a18159f642692e98261f3265533ef38e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a390d0fda2853a789ae7f658d93f8ab5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a390d0fda2853a789ae7f658d93f8ab5a">Context</a> ()</td></tr>
<tr class="separator:a390d0fda2853a789ae7f658d93f8ab5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417f0e274f7aa6367d4b599bdf6b1dd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a417f0e274f7aa6367d4b599bdf6b1dd0">Context</a> (<a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *pContext)</td></tr>
<tr class="separator:a417f0e274f7aa6367d4b599bdf6b1dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933180756124766826051bf578bae896"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a933180756124766826051bf578bae896">Context</a> (const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;other)</td></tr>
<tr class="separator:a933180756124766826051bf578bae896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245321d324cbba84bca29edf5c67fb0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a245321d324cbba84bca29edf5c67fb0c">~Context</a> ()</td></tr>
<tr class="separator:a245321d324cbba84bca29edf5c67fb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4868868cf4f55737001429d2190cecab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxn_1_1_context.html">Context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a4868868cf4f55737001429d2190cecab">operator=</a> (const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;other)</td></tr>
<tr class="separator:a4868868cf4f55737001429d2190cecab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d765ba53c711804383ff1a99ba2dc00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a1d765ba53c711804383ff1a99ba2dc00">GetUnderlyingObject</a> () const</td></tr>
<tr class="separator:a1d765ba53c711804383ff1a99ba2dc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69071bab71321a05774488342fd57a37"><td class="memItemLeft" align="right" valign="top">XnBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a69071bab71321a05774488342fd57a37">operator==</a> (const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;other)</td></tr>
<tr class="separator:a69071bab71321a05774488342fd57a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3370558161336a8cde37b54f717597"><td class="memItemLeft" align="right" valign="top">XnBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a6f3370558161336a8cde37b54f717597">operator!=</a> (const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;other)</td></tr>
<tr class="separator:a6f3370558161336a8cde37b54f717597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc68c424c840a788d0903e20a95e541"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#adfc68c424c840a788d0903e20a95e541">Init</a> ()</td></tr>
<tr class="separator:adfc68c424c840a788d0903e20a95e541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdce851bb38afd2555549c2120861ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a3cdce851bb38afd2555549c2120861ba">RunXmlScript</a> (const XnChar *strScript, <a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> &amp;scriptNode, <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *pErrors=NULL)</td></tr>
<tr class="separator:a3cdce851bb38afd2555549c2120861ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0145a926d2656d0f05399ed8d5f90ec6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a0145a926d2656d0f05399ed8d5f90ec6">RunXmlScriptFromFile</a> (const XnChar *strFileName, <a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> &amp;scriptNode, <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *pErrors=NULL)</td></tr>
<tr class="separator:a0145a926d2656d0f05399ed8d5f90ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f2dff24c434ed56b44332456ea9502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#aa0f2dff24c434ed56b44332456ea9502">InitFromXmlFile</a> (const XnChar *strFileName, <a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> &amp;scriptNode, <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *pErrors=NULL)</td></tr>
<tr class="separator:aa0f2dff24c434ed56b44332456ea9502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3589979f63d5b9ddea49b71dcdf9fc5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a3589979f63d5b9ddea49b71dcdf9fc5a">OpenFileRecording</a> (const XnChar *strFileName, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;playerNode)</td></tr>
<tr class="separator:a3589979f63d5b9ddea49b71dcdf9fc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af6b8174f1cba7da685fefa1b29dc5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a8af6b8174f1cba7da685fefa1b29dc5c">CreateMockNode</a> (<a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a> type, const XnChar *strName, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;mockNode)</td></tr>
<tr class="separator:a8af6b8174f1cba7da685fefa1b29dc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d8f78cf331911c3b1568d7546ab6e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#ad3d8f78cf331911c3b1568d7546ab6e0">CreateMockNodeBasedOn</a> (<a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;originalNode, const XnChar *strName, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;mockNode)</td></tr>
<tr class="separator:ad3d8f78cf331911c3b1568d7546ab6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b01751eaad6978275ca7b86914aace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a29b01751eaad6978275ca7b86914aace">CreateCodec</a> (<a class="el" href="_xn_types_8h.html#a0c078fc21c85436c606efc6384eeb45f">XnCodecID</a> codecID, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;initializerNode, <a class="el" href="classxn_1_1_codec.html">Codec</a> &amp;codec)</td></tr>
<tr class="separator:a29b01751eaad6978275ca7b86914aace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91783bb0e7e0ab38734a6bca5f229cf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a91783bb0e7e0ab38734a6bca5f229cf3">AddRef</a> ()</td></tr>
<tr class="separator:a91783bb0e7e0ab38734a6bca5f229cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b4f74d21dcca83a643e8566beb459d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a45b4f74d21dcca83a643e8566beb459d">Release</a> ()</td></tr>
<tr class="separator:a45b4f74d21dcca83a643e8566beb459d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06765d6feb2d6bb23deac208ee07a52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#af06765d6feb2d6bb23deac208ee07a52">AddLicense</a> (const <a class="el" href="struct_xn_license.html">XnLicense</a> &amp;License)</td></tr>
<tr class="separator:af06765d6feb2d6bb23deac208ee07a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3234930b25ac77d37bb1a40ad5b969fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a3234930b25ac77d37bb1a40ad5b969fe">EnumerateLicenses</a> (<a class="el" href="struct_xn_license.html">XnLicense</a> *&amp;aLicenses, XnUInt32 &amp;nCount) const</td></tr>
<tr class="separator:a3234930b25ac77d37bb1a40ad5b969fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a18d7c888a858748316e0437171109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a18a18d7c888a858748316e0437171109">EnumerateProductionTrees</a> (<a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a> Type, const <a class="el" href="classxn_1_1_query.html">Query</a> *pQuery, <a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;TreesList, <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *pErrors=NULL) const</td></tr>
<tr class="separator:a18a18d7c888a858748316e0437171109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dba9b1553322cfb4ecdff6b6c93a182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a4dba9b1553322cfb4ecdff6b6c93a182">CreateAnyProductionTree</a> (<a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a> type, <a class="el" href="classxn_1_1_query.html">Query</a> *pQuery, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;node, <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *pErrors=NULL)</td></tr>
<tr class="separator:a4dba9b1553322cfb4ecdff6b6c93a182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa8daba096969ff9f16b7e8cb35cf93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#adaa8daba096969ff9f16b7e8cb35cf93">CreateProductionTree</a> (<a class="el" href="classxn_1_1_node_info.html">NodeInfo</a> &amp;Tree, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;node)</td></tr>
<tr class="separator:adaa8daba096969ff9f16b7e8cb35cf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8df8eeea43d4c70d0ecf9c440e1f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#abc8df8eeea43d4c70d0ecf9c440e1f88">EnumerateExistingNodes</a> (<a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;list) const</td></tr>
<tr class="separator:abc8df8eeea43d4c70d0ecf9c440e1f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec366a6be9ab759e03fc626f2cbe86d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#acec366a6be9ab759e03fc626f2cbe86d">EnumerateExistingNodes</a> (<a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;list, <a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a> type) const</td></tr>
<tr class="separator:acec366a6be9ab759e03fc626f2cbe86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec285d911d0fcff6a2bbd14ecd56c63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a0ec285d911d0fcff6a2bbd14ecd56c63">FindExistingNode</a> (<a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a> type, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;node) const</td></tr>
<tr class="separator:a0ec285d911d0fcff6a2bbd14ecd56c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac42a38c12394de3ae9be7182e4034bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#aac42a38c12394de3ae9be7182e4034bb">GetProductionNodeByName</a> (const XnChar *strInstanceName, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;node) const</td></tr>
<tr class="separator:aac42a38c12394de3ae9be7182e4034bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f50008f2b2884d8d2fca732ecff8a5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a4f50008f2b2884d8d2fca732ecff8a5e">GetProductionNodeInfoByName</a> (const XnChar *strInstanceName, <a class="el" href="classxn_1_1_node_info.html">NodeInfo</a> &amp;nodeInfo) const</td></tr>
<tr class="separator:a4f50008f2b2884d8d2fca732ecff8a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa5173b7c32b98d344ab2c8634f2cb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#affa5173b7c32b98d344ab2c8634f2cb7">StartGeneratingAll</a> ()</td></tr>
<tr class="separator:affa5173b7c32b98d344ab2c8634f2cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf4d38b0cc4b50a376a83c4761670b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#aecf4d38b0cc4b50a376a83c4761670b5">StopGeneratingAll</a> ()</td></tr>
<tr class="separator:aecf4d38b0cc4b50a376a83c4761670b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdabaa87787c0e3b61e37619c6a6590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#adcdabaa87787c0e3b61e37619c6a6590">SetGlobalMirror</a> (XnBool bMirror)</td></tr>
<tr class="separator:adcdabaa87787c0e3b61e37619c6a6590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585e4474303bb536ecdee5b1743cd8e7"><td class="memItemLeft" align="right" valign="top">XnBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a585e4474303bb536ecdee5b1743cd8e7">GetGlobalMirror</a> ()</td></tr>
<tr class="separator:a585e4474303bb536ecdee5b1743cd8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9694adb05ee44e1d9a4407f7053672d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a9694adb05ee44e1d9a4407f7053672d8">GetGlobalErrorState</a> ()</td></tr>
<tr class="separator:a9694adb05ee44e1d9a4407f7053672d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdfff9d6af00fc66c67223409af7f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a3cdfff9d6af00fc66c67223409af7f33">RegisterToErrorStateChange</a> (<a class="el" href="_xn_types_8h.html#a1cdc72293c9f5f668bb6fb5cda5f0397">XnErrorStateChangedHandler</a> handler, void *pCookie, <a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;hCallback)</td></tr>
<tr class="separator:a3cdfff9d6af00fc66c67223409af7f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45df3c90dc12709c777ef1b531bab8b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a45df3c90dc12709c777ef1b531bab8b3">UnregisterFromErrorStateChange</a> (<a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> hCallback)</td></tr>
<tr class="separator:a45df3c90dc12709c777ef1b531bab8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6a81364fd5bbf1b22123936961bef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#abf6a81364fd5bbf1b22123936961bef4">RegisterToNodeCreation</a> (<a class="el" href="classxn_1_1_context.html#a7f2fb2123f2e753d0c71d7c7aa9e9479">NodeCreationHandler</a> handler, void *pCookie, <a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;hCallback)</td></tr>
<tr class="separator:abf6a81364fd5bbf1b22123936961bef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2714f66a8247705422a56621574671d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a2714f66a8247705422a56621574671d0">UnregisterFromNodeCreation</a> (<a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> hCallback)</td></tr>
<tr class="separator:a2714f66a8247705422a56621574671d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd23341f93552deca937733a6b82ab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#accd23341f93552deca937733a6b82ab2">RegisterToNodeDestruction</a> (<a class="el" href="classxn_1_1_context.html#a18159f642692e98261f3265533ef38e0">NodeDestructionHandler</a> handler, void *pCookie, <a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;hCallback)</td></tr>
<tr class="separator:accd23341f93552deca937733a6b82ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85fb69ce08a373a9a6fdd25d697dd4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#aa85fb69ce08a373a9a6fdd25d697dd4f">UnregisterFromNodeDestruction</a> (<a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> hCallback)</td></tr>
<tr class="separator:aa85fb69ce08a373a9a6fdd25d697dd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52929d2a535166b18098e066900f9d59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a52929d2a535166b18098e066900f9d59">WaitAndUpdateAll</a> ()</td></tr>
<tr class="separator:a52929d2a535166b18098e066900f9d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fab043d7b6d60728511527a1d5c090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090">WaitAnyUpdateAll</a> ()</td></tr>
<tr class="separator:a17fab043d7b6d60728511527a1d5c090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bab84f35a855639d485da99a05c585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#ad4bab84f35a855639d485da99a05c585">WaitOneUpdateAll</a> (<a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;node)</td></tr>
<tr class="separator:ad4bab84f35a855639d485da99a05c585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae498b727aa0fdade75f91bdb2563f88c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#ae498b727aa0fdade75f91bdb2563f88c">WaitNoneUpdateAll</a> ()</td></tr>
<tr class="separator:ae498b727aa0fdade75f91bdb2563f88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a93361b3df262a823d1df3e5b733b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a5a93361b3df262a823d1df3e5b733b2b">AutoEnumerateOverSingleInput</a> (<a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;List, <a class="el" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a> &amp;description, const XnChar *strCreationInfo, <a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a> InputType, <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *pErrors, <a class="el" href="classxn_1_1_query.html">Query</a> *pQuery=NULL) const</td></tr>
<tr class="separator:a5a93361b3df262a823d1df3e5b733b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b3626c96bda6f9423de567061b05ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#ae9b3626c96bda6f9423de567061b05ae">SetHandle</a> (<a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *pContext)</td></tr>
<tr class="separator:ae9b3626c96bda6f9423de567061b05ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbc2a151989fe58879aa1f0bef81e85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#accbc2a151989fe58879aa1f0bef81e85">TakeOwnership</a> (<a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *pContext)</td></tr>
<tr class="separator:accbc2a151989fe58879aa1f0bef81e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad5aba10f694d2eab283598c9e1f1ee3b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#ad5aba10f694d2eab283598c9e1f1ee3b">FreeLicensesList</a> (<a class="el" href="struct_xn_license.html">XnLicense</a> aLicenses[])</td></tr>
<tr class="separator:ad5aba10f694d2eab283598c9e1f1ee3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A context is a workspace where the application builds an OpenNI production graph. It contains methods for managing the production graph.</p>
<p>In order to use any of the OpenNI functionality you must first construct a <a class="el" href="classxn_1_1_context.html">Context</a> object and initialize it. Prior to this, the application cannot do anything with OpenNI.</p>
<p>For a comprehensive overview to the <a class="el" href="classxn_1_1_context.html">Context</a> class and its members, see <a class="el" href="conc_context.html">Overview to Contexts</a>.</p>
<h1><a class="anchor" id="context_global_error_event"></a>
Event: 'Global Error State Change'</h1>
<p>Signals that the error state of any of the nodes has changed.</p>
<p>This event can be used by the application to get a signal as soon as any error occurs in one of the production nodes. The global error state aggregates error state from all the production nodes in the context.</p>
<p>Use <a class="el" href="classxn_1_1_context.html#a3cdfff9d6af00fc66c67223409af7f33">RegisterToErrorStateChange()</a> and <a class="el" href="classxn_1_1_context.html#a45df3c90dc12709c777ef1b531bab8b3">UnregisterFromErrorStateChange()</a> for using this event.</p>
<h1><a class="anchor" id="context_node_creation_event"></a>
Event: 'Node Creation'</h1>
<p>Signals that a new node was created in the context production graph.</p>
<p>Use <a class="el" href="classxn_1_1_context.html#abf6a81364fd5bbf1b22123936961bef4">RegisterToNodeCreation()</a> and <a class="el" href="classxn_1_1_context.html#a2714f66a8247705422a56621574671d0">UnregisterFromNodeCreation()</a> for using this event.</p>
<h1><a class="anchor" id="context_node_destruction_event"></a>
Event: 'Node Destruction'</h1>
<p>Signals that a node was removed from the context production graph, and destroyed.</p>
<p>Use <a class="el" href="classxn_1_1_context.html#accd23341f93552deca937733a6b82ab2">RegisterToNodeDestruction()</a> and <a class="el" href="classxn_1_1_context.html#aa85fb69ce08a373a9a6fdd25d697dd4f">UnregisterFromNodeDestruction()</a> for using this event. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7f2fb2123f2e753d0c71d7c7aa9e9479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2fb2123f2e753d0c71d7c7aa9e9479">&#9670;&nbsp;</a></span>NodeCreationHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*  xn::Context::NodeCreationHandler) (<a class="el" href="classxn_1_1_context.html">Context</a> &amp;context, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;createdNode, void *pCookie)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for the <a class="el" href="classxn_1_1_context.html#context_node_creation_event">'Node Creation'</a> event handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context that raised this event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createdNode</td><td>The id of the hand that disappeared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCookie</td><td>A user-provided cookie that was given when registering to this event.</td></tr>
  </table>
  </dd>
</dl>
<p>Example for such a handler: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> XN_CALLBACK_TYPE OnNodeCreation(<a class="code" href="classxn_1_1_context.html#a390d0fda2853a789ae7f658d93f8ab5a">Context</a>&amp; context, ProductionNode&amp; createdNode, <span class="keywordtype">void</span>* pCookie)</div><div class="line">{}</div></div><!-- fragment --> 
</div>
</div>
<a id="a18159f642692e98261f3265533ef38e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18159f642692e98261f3265533ef38e0">&#9670;&nbsp;</a></span>NodeDestructionHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*  xn::Context::NodeDestructionHandler) (<a class="el" href="classxn_1_1_context.html">Context</a> &amp;context, const XnChar *strDestroyedNodeName, void *pCookie)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback prototype for the <a class="el" href="classxn_1_1_context.html#context_node_destruction_event">'Node Destruction'</a> event handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context that raised this event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strDestroyedNodeName</td><td>The name of the node that was destroyed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCookie</td><td>A user-provided cookie that was given when registering to this event.</td></tr>
  </table>
  </dd>
</dl>
<p>Example for such a handler: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> XN_CALLBACK_TYPE OnNodeDestruction(<a class="code" href="classxn_1_1_context.html#a390d0fda2853a789ae7f658d93f8ab5a">Context</a>&amp; context, <span class="keyword">const</span> XnChar* strDestroyedNodeName, <span class="keywordtype">void</span>* pCookie)</div><div class="line">{}</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a390d0fda2853a789ae7f658d93f8ab5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390d0fda2853a789ae7f658d93f8ab5a">&#9670;&nbsp;</a></span>Context() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xn::Context::Context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ctor </p>

</div>
</div>
<a id="a417f0e274f7aa6367d4b599bdf6b1dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417f0e274f7aa6367d4b599bdf6b1dd0">&#9670;&nbsp;</a></span>Context() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xn::Context::Context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ctor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>Underlying C object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a933180756124766826051bf578bae896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933180756124766826051bf578bae896">&#9670;&nbsp;</a></span>Context() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xn::Context::Context </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy Ctor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Another context. Note that the context will only be destroyed when the original object is destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a245321d324cbba84bca29edf5c67fb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245321d324cbba84bca29edf5c67fb0c">&#9670;&nbsp;</a></span>~Context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xn::Context::~Context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dtor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af06765d6feb2d6bb23deac208ee07a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06765d6feb2d6bb23deac208ee07a52">&#9670;&nbsp;</a></span>AddLicense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::AddLicense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xn_license.html">XnLicense</a> &amp;&#160;</td>
          <td class="paramname"><em>License</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For full details and usage, see <a class="el" href="group__lic.html#gabe1f7682dce8f5171f43f6eab7e30f41">xnAddLicense</a> </p>

</div>
</div>
<a id="a91783bb0e7e0ab38734a6bca5f229cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91783bb0e7e0ab38734a6bca5f229cf3">&#9670;&nbsp;</a></span>AddRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::AddRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a reference to the context object. For full details and usage, see <a class="el" href="group__context.html#ga598906a4be124df2f5b4a7c089b0598e">xnContextAddRef</a> </p>

</div>
</div>
<a id="a5a93361b3df262a823d1df3e5b733b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a93361b3df262a823d1df3e5b733b2b">&#9670;&nbsp;</a></span>AutoEnumerateOverSingleInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::AutoEnumerateOverSingleInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;&#160;</td>
          <td class="paramname"><em>List</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XnChar *&#160;</td>
          <td class="paramname"><em>strCreationInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a>&#160;</td>
          <td class="paramname"><em>InputType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *&#160;</td>
          <td class="paramname"><em>pErrors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_query.html">Query</a> *&#160;</td>
          <td class="paramname"><em>pQuery</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For full details and usage, see <a class="el" href="group__utils.html#ga57d7bd49dda18e9bc37497f4a919463c">xnAutoEnumerateOverSingleInput</a> </p>

</div>
</div>
<a id="a4dba9b1553322cfb4ecdff6b6c93a182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dba9b1553322cfb4ecdff6b6c93a182">&#9670;&nbsp;</a></span>CreateAnyProductionTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::CreateAnyProductionTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_query.html">Query</a> *&#160;</td>
          <td class="paramname"><em>pQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *&#160;</td>
          <td class="paramname"><em>pErrors</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates for production nodes of a specific node type, and creates the first production node found of that type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Requested node type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pQuery</td><td>Optional. A query object that can be used to filter results. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Handle to the newly created node. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pErrors</td><td>Optional. To contain enumeration errors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>This method is a 'shortcut' version of using the <a class="el" href="classxn_1_1_context.html#a18a18d7c888a858748316e0437171109">EnumerateProductionTrees()</a> method and then passing the first result to <a class="el" href="classxn_1_1_context.html#adaa8daba096969ff9f16b7e8cb35cf93">CreateProductionTree()</a>. Thus, this method is exactly like the <b>Create()</b> method for nodes.</p>
<p>Other ways of creating a production graph let the application retrieve a complete list of alternatives and then choose the most appropriate alternative.</p>
<p>This method is the method used by the above XML script methods to create the <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> objects. The XML method runs the XML script, and for each node description the XML method runs this function to create that node.</p>
<p>Using this function is called 'creating a node from the context'. You can also create a node by invoking the <b>Create</b> method of the node itself, e.g., the <a class="el" href="classxn_1_1_hands_generator.html#a35406ad94eed27f3ff9b8744e5a29ac3">Create()</a> method of a <a class="el" href="classxn_1_1_hands_generator.html">HandsGenerator</a> node.</p>
<p>By default, this method does not enable the production nodes to start generating data immediately on creation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="prod_graph.html#create_method">Understanding the Create() method</a> for more detail. </dd></dl>

</div>
</div>
<a id="a29b01751eaad6978275ca7b86914aace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b01751eaad6978275ca7b86914aace">&#9670;&nbsp;</a></span>CreateCodec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::CreateCodec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a0c078fc21c85436c606efc6384eeb45f">XnCodecID</a>&#160;</td>
          <td class="paramname"><em>codecID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>initializerNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_codec.html">Codec</a> &amp;&#160;</td>
          <td class="paramname"><em>codec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For full details and usage, see <a class="el" href="group__codec.html#ga4b1c9d8aa1a4c8b9f683aa1b2f612fd1">xnCreateCodec</a> </p>

</div>
</div>
<a id="a8af6b8174f1cba7da685fefa1b29dc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af6b8174f1cba7da685fefa1b29dc5c">&#9670;&nbsp;</a></span>CreateMockNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::CreateMockNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XnChar *&#160;</td>
          <td class="paramname"><em>strName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>mockNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a production node which is only a mock. This node does not represent an actual node, but only keeps a state and implements an interface above it. Mock nodes are useful when simulating nodes for playing recordings, or for use in tests. See also <a class="el" href="group__context.html#ga1cab33ab4c7da00726a25398e3a1d05a">xnCreateMockNodeBasedOn()</a>. For full details and usage, see <a class="el" href="group__context.html#ga543daf92a09af0840d771baea0862df7">xnCreateMockNode</a> </p>

</div>
</div>
<a id="ad3d8f78cf331911c3b1568d7546ab6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d8f78cf331911c3b1568d7546ab6e0">&#9670;&nbsp;</a></span>CreateMockNodeBasedOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::CreateMockNodeBasedOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>originalNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XnChar *&#160;</td>
          <td class="paramname"><em>strName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>mockNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a production node which is only a mock, base on the type and properties of another node. This node does not represent an actual node, but only keeps a state and implements an interface above it. Mock nodes are useful when simulating nodes for playing recordings, or for use in tests. See also <a class="el" href="group__context.html#ga543daf92a09af0840d771baea0862df7">xnCreateMockNode()</a>. For full details and usage, see <a class="el" href="group__context.html#ga1cab33ab4c7da00726a25398e3a1d05a">xnCreateMockNodeBasedOn</a> </p>

</div>
</div>
<a id="adaa8daba096969ff9f16b7e8cb35cf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa8daba096969ff9f16b7e8cb35cf93">&#9670;&nbsp;</a></span>CreateProductionTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::CreateProductionTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_node_info.html">NodeInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>Tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a production node from the information supplied in a <a class="el" href="classxn_1_1_node_info.html">xn::NodeInfo</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Tree</td><td>Node properties for creating the new node. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Reference to the new <a class="el" href="classxn_1_1_production_node.html">xn::ProductionNode</a> object.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>The application gets the <a class="el" href="classxn_1_1_node_info.html">NodeInfo</a> object by choosing it from the list returned by the <a class="el" href="classxn_1_1_context.html#a18a18d7c888a858748316e0437171109">xn::Context::EnumerateProductionTrees()</a> method.</p>
<p>If the new production node requires additional nodes for its input, and those nodes do not yet exist, then this method creates those additional nodes also and associates them with the "original" new production node. </p>

</div>
</div>
<a id="abc8df8eeea43d4c70d0ecf9c440e1f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8df8eeea43d4c70d0ecf9c440e1f88">&#9670;&nbsp;</a></span>EnumerateExistingNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::EnumerateExistingNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all the context's existing created nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">list</td><td>List of the context's existing created nodes.</td></tr>
  </table>
  </dd>
</dl>
<p>You can use the <a class="el" href="classxn_1_1_node_info_list.html#aac62cedc1b2b3ce355539958988f4728">xn::NodeInfoList::FilterList()</a> method to filter the returned list of existing nodes. </p>

</div>
</div>
<a id="acec366a6be9ab759e03fc626f2cbe86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec366a6be9ab759e03fc626f2cbe86d">&#9670;&nbsp;</a></span>EnumerateExistingNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::EnumerateExistingNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of the context's existing created nodes filtered by type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>List of the context's existing created nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type to enumerate for.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks</b></p>
<p>Returns the list after filtering them by type, so it returns a list of the created nodes of the specific type only.</p>
<p>An example of a typical case of returning a list of two nodes of the same type is where there are two sensors in a 3D set-up and you need to retrieve the corresponding two depth nodes to generate data from them.</p>
<p>You can use the <a class="el" href="classxn_1_1_node_info_list.html#aac62cedc1b2b3ce355539958988f4728">xn::NodeInfoList::FilterList()</a> method to filter the returned list of existing nodes. </p>

</div>
</div>
<a id="a3234930b25ac77d37bb1a40ad5b969fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3234930b25ac77d37bb1a40ad5b969fe">&#9670;&nbsp;</a></span>EnumerateLicenses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::EnumerateLicenses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xn_license.html">XnLicense</a> *&amp;&#160;</td>
          <td class="paramname"><em>aLicenses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XnUInt32 &amp;&#160;</td>
          <td class="paramname"><em>nCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For full details and usage, see <a class="el" href="group__lic.html#gaa1753b7044eb05c1640b9f47c05d33c1">xnEnumerateLicenses</a> </p>

</div>
</div>
<a id="a18a18d7c888a858748316e0437171109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a18d7c888a858748316e0437171109">&#9670;&nbsp;</a></span>EnumerateProductionTrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::EnumerateProductionTrees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a>&#160;</td>
          <td class="paramname"><em>Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxn_1_1_query.html">Query</a> *&#160;</td>
          <td class="paramname"><em>pQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;&#160;</td>
          <td class="paramname"><em>TreesList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *&#160;</td>
          <td class="paramname"><em>pErrors</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates all available production nodes for a specific node type (e.g., the application wants to create a depth generator node) and returns a full list of matching production nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Type</td><td>Requested node type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pQuery</td><td>Optional. A query object that can be used to filter results. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TreesList</td><td>List of possible production nodes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pErrors</td><td>Optional. To contain enumeration errors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>The application chooses one of the nodes from the node list returned by this method and uses it as input to the <a class="el" href="classxn_1_1_context.html#adaa8daba096969ff9f16b7e8cb35cf93">xn::Context::CreateProductionTree()</a> method to create a new production node.</p>
<p>Using this method to help create a production node offers the greatest flexibility since it returns a complete list of matching production nodes and so the application can then choose the most suitable node.</p>
<p>By contrast, using <a class="el" href="classxn_1_1_context.html#a4dba9b1553322cfb4ecdff6b6c93a182">CreateAnyProductionTree()</a> or a node's <b>Create()</b> method creates a node from the first matching node that satisfies the query. </p>

</div>
</div>
<a id="a0ec285d911d0fcff6a2bbd14ecd56c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec285d911d0fcff6a2bbd14ecd56c63">&#9670;&nbsp;</a></span>FindExistingNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::FindExistingNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an existing created node of a specified type and returns a reference to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of node to search for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">node</td><td>Reference to an existing created node that was found.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks</b></p>
<p>This method returns only the first node it finds; this method does not return the entire list of matching nodes. Compare this with the <a class="el" href="classxn_1_1_context.html#abc8df8eeea43d4c70d0ecf9c440e1f88">xn::Context::EnumerateExistingNodes()</a> method, which returns the entire list of matching nodes. A typical usage is that the application already created all the nodes from XML. Then, when it needs to start generating data from a particular node, e.g., the skeleton data, it will call FindExistingNode specifying the skeleton type, and it will get it and start using it.</p>
<p>This method does not provide a query parameter (compare with <a class="el" href="classxn_1_1_context.html#abc8df8eeea43d4c70d0ecf9c440e1f88">xn::Context::EnumerateExistingNodes</a>). </p>

</div>
</div>
<a id="ad5aba10f694d2eab283598c9e1f1ee3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5aba10f694d2eab283598c9e1f1ee3b">&#9670;&nbsp;</a></span>FreeLicensesList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xn::Context::FreeLicensesList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xn_license.html">XnLicense</a>&#160;</td>
          <td class="paramname"><em>aLicenses</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For full details and usage, see <a class="el" href="group__lic.html#ga504810407ef9b73ab42d34db1228d125">xnFreeLicensesList</a> </p>

</div>
</div>
<a id="a9694adb05ee44e1d9a4407f7053672d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9694adb05ee44e1d9a4407f7053672d8">&#9670;&nbsp;</a></span>GetGlobalErrorState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::GetGlobalErrorState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the global error state of the context. If one of the nodes in the context is in error state, that state will be returned. If more than one node is in error state, XN_STATUS_MULTIPLE_NODES_ERROR is returned. An application can query each node error state by calling <a class="el" href="group__err__state.html#ga8d8ea67a479a6a138b6c39b6d4f86049">xnGetNodeErrorState()</a>. For full details and usage, see <a class="el" href="group__context.html#gad71392e3e7bb8a07fa791162a248aece">xnGetGlobalErrorState</a> </p>

</div>
</div>
<a id="a585e4474303bb536ecdee5b1743cd8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585e4474303bb536ecdee5b1743cd8e7">&#9670;&nbsp;</a></span>GetGlobalMirror()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XnBool xn::Context::GetGlobalMirror </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current state of the GlobalMirror flag. </p>

</div>
</div>
<a id="aac42a38c12394de3ae9be7182e4034bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac42a38c12394de3ae9be7182e4034bb">&#9670;&nbsp;</a></span>GetProductionNodeByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::GetProductionNodeByName </td>
          <td>(</td>
          <td class="paramtype">const XnChar *&#160;</td>
          <td class="paramname"><em>strInstanceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For full details and usage, see <a class="el" href="group__context.html#ga354130d1c691d598a97c325340d715df">xnGetNodeHandleByName</a> </p>

</div>
</div>
<a id="a4f50008f2b2884d8d2fca732ecff8a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f50008f2b2884d8d2fca732ecff8a5e">&#9670;&nbsp;</a></span>GetProductionNodeInfoByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::GetProductionNodeInfoByName </td>
          <td>(</td>
          <td class="paramtype">const XnChar *&#160;</td>
          <td class="paramname"><em>strInstanceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_node_info.html">NodeInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For full details and usage, see <a class="el" href="group__context.html#ga354130d1c691d598a97c325340d715df">xnGetNodeHandleByName</a> </p>

</div>
</div>
<a id="a1d765ba53c711804383ff1a99ba2dc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d765ba53c711804383ff1a99ba2dc00">&#9670;&nbsp;</a></span>GetUnderlyingObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a>* xn::Context::GetUnderlyingObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the underlying C object </p>

</div>
</div>
<a id="adfc68c424c840a788d0903e20a95e541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc68c424c840a788d0903e20a95e541">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds the context's general software environment. </p>
<p>This method initializes runtime variables and data structures, and examines all registered plug-ins to learn the purpose and specific capabilities of each. In particular, during initialization the context initialization examines all registered plug-ins to learn the purpose and specific capabilities of each. For example, one plug-in is for creating a skeleton node, and another plug-in is for creating a depth node. Thus an entire database is built of plug-ins that can be queried according to vendor, model, and capabilities of each.</p>
<p>Once you have completed the initialization you can create nodes that are based on the plug-ins that OpenNI has discovered by this initialization process. </p>

</div>
</div>
<a id="aa0f2dff24c434ed56b44332456ea9502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f2dff24c434ed56b44332456ea9502">&#9670;&nbsp;</a></span>InitFromXmlFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::InitFromXmlFile </td>
          <td>(</td>
          <td class="paramtype">const XnChar *&#160;</td>
          <td class="paramname"><em>strFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> &amp;&#160;</td>
          <td class="paramname"><em>scriptNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *&#160;</td>
          <td class="paramname"><em>pErrors</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shorthand combination of two other initialization methods - <a class="el" href="classxn_1_1_context.html#adfc68c424c840a788d0903e20a95e541">Init()</a> and then <a class="el" href="classxn_1_1_context.html#a0145a926d2656d0f05399ed8d5f90ec6">RunXmlScriptFromFile()</a> - to initialize the context object and then create a production graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strFileName</td><td>Name of file containing an XML script. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scriptNode</td><td><a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> object as the root to all the nodes created from the XML file. When no longer needed, the node can be released, causing all the created nodes to decrement their reference counts. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pErrors</td><td>Optional. To be filled with enumeration errors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>The XML script file describes all the nodes you want to create. For each node description in the XML file, this method creates a <a class="el" href="classxn_1_1_production_node.html">xn::ProductionNode</a> object. </p>

</div>
</div>
<a id="a3589979f63d5b9ddea49b71dcdf9fc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3589979f63d5b9ddea49b71dcdf9fc5a">&#9670;&nbsp;</a></span>OpenFileRecording()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::OpenFileRecording </td>
          <td>(</td>
          <td class="paramtype">const XnChar *&#160;</td>
          <td class="paramname"><em>strFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>playerNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recreates a production graph from a recorded ONI file and then replays the data generation exactly as it was recorded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strFileName</td><td>Name of the recorded file to be run. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">playerNode</td><td>Returns a <a class="el" href="classxn_1_1_player.html">xn::Player</a> object through which playback can be controlled, e.g., seeking and setting playback speed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>OpenNI provides great flexibility of recording. You can decide you want to record only the final output, e.g., just a skeleton in movement; or record both the output skeleton and the depth input; or record only the depth input and then recreate the skeleton at run-time after reading the recorded raw depth data. You can also choose which nodes to record. </p>

</div>
</div>
<a id="a6f3370558161336a8cde37b54f717597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3370558161336a8cde37b54f717597">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XnBool xn::Context::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if two context objects are <em>not</em> references to the same context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Another object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4868868cf4f55737001429d2190cecab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4868868cf4f55737001429d2190cecab">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxn_1_1_context.html">Context</a>&amp; xn::Context::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a69071bab71321a05774488342fd57a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69071bab71321a05774488342fd57a37">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XnBool xn::Context::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if two context objects are references to the same context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Another object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cdfff9d6af00fc66c67223409af7f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdfff9d6af00fc66c67223409af7f33">&#9670;&nbsp;</a></span>RegisterToErrorStateChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::RegisterToErrorStateChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a1cdc72293c9f5f668bb6fb5cda5f0397">XnErrorStateChangedHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>hCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers an event handler for the 'Global Error State Change' event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Callback function to be invoked when the event is raised. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCookie</td><td>User's cookie, to be delivered to the callback. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hCallback</td><td>Handle to the callback to be used for unregistering it.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameters, see <a class="el" href="conc_events.html#reg_to_events">Registering to Events</a>. </p>

</div>
</div>
<a id="abf6a81364fd5bbf1b22123936961bef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6a81364fd5bbf1b22123936961bef4">&#9670;&nbsp;</a></span>RegisterToNodeCreation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::RegisterToNodeCreation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_context.html#a7f2fb2123f2e753d0c71d7c7aa9e9479">NodeCreationHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>hCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers an event handler for the 'Node Creation' event. see <a class="el" href="classxn_1_1_context.html#context_node_creation_event">Event: 'Node Creation'</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Callback function to be invoked when the event is raised. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCookie</td><td>User's cookie, to be delivered to the callback. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hCallback</td><td>Handle to the callback to be used for unregistering it.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameters, see <a class="el" href="conc_events.html#reg_to_events">Registering to Events</a>. </p>

</div>
</div>
<a id="accd23341f93552deca937733a6b82ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd23341f93552deca937733a6b82ab2">&#9670;&nbsp;</a></span>RegisterToNodeDestruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::RegisterToNodeDestruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_context.html#a18159f642692e98261f3265533ef38e0">NodeDestructionHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>hCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers an event handler for the 'Node Destruction' event. see <a class="el" href="classxn_1_1_context.html#context_node_destruction_event">Event: 'Node Destruction'</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Callback function to be invoked when the event is raised. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCookie</td><td>User's cookie, to be delivered to the callback. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hCallback</td><td>Handle to the callback to be used for unregistering it.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameters, see <a class="el" href="conc_events.html#reg_to_events">Registering to Events</a>. </p>

</div>
</div>
<a id="a45b4f74d21dcca83a643e8566beb459d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b4f74d21dcca83a643e8566beb459d">&#9670;&nbsp;</a></span>Release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Context::Release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Releases a context object, decreasing its ref count by 1. If reference count has reached 0, the context will be destroyed. For full details and usage, see <a class="el" href="group__context.html#ga312163c183d1fecd902927a76d914183">xnContextRelease</a> </p>

</div>
</div>
<a id="a3cdce851bb38afd2555549c2120861ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdce851bb38afd2555549c2120861ba">&#9670;&nbsp;</a></span>RunXmlScript()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::RunXmlScript </td>
          <td>(</td>
          <td class="paramtype">const XnChar *&#160;</td>
          <td class="paramname"><em>strScript</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> &amp;&#160;</td>
          <td class="paramname"><em>scriptNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *&#160;</td>
          <td class="paramname"><em>pErrors</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs an XML script string to build a production graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strScript</td><td>String containing an XML script. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scriptNode</td><td><a class="el" href="classxn_1_1_script_node.html">xn::ScriptNode</a> object as the root to all the nodes created from the XML file. When no longer needed, the node can be released, causing all the created nodes to decrement their reference counts. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pErrors</td><td>Optional. To be filled with enumeration errors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>For a full description of the XML structure, see <a class="el" href="xmlscripts.html">Xml Scripts</a>. Compare this method with initialization methods that run an XML script from a file. </p>

</div>
</div>
<a id="a0145a926d2656d0f05399ed8d5f90ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0145a926d2656d0f05399ed8d5f90ec6">&#9670;&nbsp;</a></span>RunXmlScriptFromFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::RunXmlScriptFromFile </td>
          <td>(</td>
          <td class="paramtype">const XnChar *&#160;</td>
          <td class="paramname"><em>strFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> &amp;&#160;</td>
          <td class="paramname"><em>scriptNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *&#160;</td>
          <td class="paramname"><em>pErrors</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs an XML script file to build a production graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strFileName</td><td>Name of file containing an XML script. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scriptNode</td><td>scriptNode object as the root to all the nodes created from the XML file. When no longer needed, the node can be released, causing all the created nodes to decrement their reference counts. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pErrors</td><td>Optional. To be filled with enumeration errors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>The XML script file describes all the nodes you want to create. For each node description in the XML file, this method creates a <a class="el" href="classxn_1_1_production_node.html">xn::ProductionNode</a> object. </p>

</div>
</div>
<a id="adcdabaa87787c0e3b61e37619c6a6590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdabaa87787c0e3b61e37619c6a6590">&#9670;&nbsp;</a></span>SetGlobalMirror()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::SetGlobalMirror </td>
          <td>(</td>
          <td class="paramtype">XnBool&#160;</td>
          <td class="paramname"><em>bMirror</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables/disables the GlobalMirror flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bMirror</td><td>New mirroring state.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>See <a class="el" href="conc_global_mirror.html">Global Mirror</a> for understanding of the 'Global Mirror' concept. </p>

</div>
</div>
<a id="ae9b3626c96bda6f9423de567061b05ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b3626c96bda6f9423de567061b05ae">&#9670;&nbsp;</a></span>SetHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Context::SetHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces the underlying C object pointed to by this object. </p>

</div>
</div>
<a id="affa5173b7c32b98d344ab2c8634f2cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa5173b7c32b98d344ab2c8634f2cb7">&#9670;&nbsp;</a></span>StartGeneratingAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::StartGeneratingAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures all created <a class="el" href="glossary.html#dict_gen_node">generator nodes</a> are generating data. </p>

</div>
</div>
<a id="aecf4d38b0cc4b50a376a83c4761670b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf4d38b0cc4b50a376a83c4761670b5">&#9670;&nbsp;</a></span>StopGeneratingAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::StopGeneratingAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures all <a class="el" href="glossary.html#dict_gen_node">generator nodes</a> are not generating data. </p>

</div>
</div>
<a id="accbc2a151989fe58879aa1f0bef81e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbc2a151989fe58879aa1f0bef81e85">&#9670;&nbsp;</a></span>TakeOwnership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Context::TakeOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45df3c90dc12709c777ef1b531bab8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45df3c90dc12709c777ef1b531bab8b3">&#9670;&nbsp;</a></span>UnregisterFromErrorStateChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Context::UnregisterFromErrorStateChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a>&#160;</td>
          <td class="paramname"><em>hCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters an event handler for the 'Global Error State Change' event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCallback</td><td>Handle received from registration.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameter, see <a class="el" href="conc_events.html#unreg_from_events">Unregistering from Events</a> . </p>

</div>
</div>
<a id="a2714f66a8247705422a56621574671d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2714f66a8247705422a56621574671d0">&#9670;&nbsp;</a></span>UnregisterFromNodeCreation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Context::UnregisterFromNodeCreation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a>&#160;</td>
          <td class="paramname"><em>hCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters an event handler for the 'Node Creation' event. see <a class="el" href="classxn_1_1_context.html#context_node_creation_event">Event: 'Node Creation'</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCallback</td><td>Handle received from registration.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameter, see <a class="el" href="conc_events.html#unreg_from_events">Unregistering from Events</a>. </p>

</div>
</div>
<a id="aa85fb69ce08a373a9a6fdd25d697dd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85fb69ce08a373a9a6fdd25d697dd4f">&#9670;&nbsp;</a></span>UnregisterFromNodeDestruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Context::UnregisterFromNodeDestruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a>&#160;</td>
          <td class="paramname"><em>hCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters an event handler for the 'Node Destruction' event. see <a class="el" href="classxn_1_1_context.html#context_node_destruction_event">Event: 'Node Destruction'</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hCallback</td><td>Handle received from registration.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameter, see <a class="el" href="conc_events.html#unreg_from_events">Unregistering from Events</a>. </p>

</div>
</div>
<a id="a52929d2a535166b18098e066900f9d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52929d2a535166b18098e066900f9d59">&#9670;&nbsp;</a></span>WaitAndUpdateAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::WaitAndUpdateAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates all generator nodes in the context to their latest available data, first waiting for all nodes to have new data available. </p>
<p><b>Remarks</b></p>
<p>This method requests from OpenNI to cause all nodes in the context's Production Graph that have new data available to update their application buffers with the new data, each node updating its own application buffer.</p>
<p>Before OpenNI causes the data updates, it waits until <b>all</b> the nodes have notified that they have new data available. On receiving all the 'new data available' notifications, OpenNI then causes all nodes with new data available to update their application buffers with their new data. At this stage the generator nodes have "generated" new data. This method then stops waiting and returns a success status. The application can now read the newly generated data.</p>
<dl class="section note"><dt>Note</dt><dd>Using this method is not recommended for most applications since it requires <em>all</em> the nodes to have new data. Consider instead using <a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090">WaitAnyUpdateAll()</a> or <a class="el" href="classxn_1_1_context.html#ad4bab84f35a855639d485da99a05c585">WaitOneUpdateAll()</a>. Typical applications use the <a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090" title="Updates all generator nodes in the context to their latest available data, first waiting for any of t...">WaitAnyUpdateAll()</a> method.</dd></dl>
<p>An error situation is defined as: after a preset timeout, not all nodes have yet notified OpenNI they have new data available. On error, the method stops waiting and returns an error status. None of the nodes update their application buffers.</p>
<p>See <a class="el" href="conc_updating_data.html#conc_updating_data__summary_of_wait_fns">'Wait and Update' Methods</a> for an overview to the <a class="el" href="conc_updating_data.html">'WaitXUpdateAll'</a> methods and how to read the data from the nodes.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">XN_STATUS_WAIT_DATA_TIMEOUT</td><td>No new data available within 2 seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17fab043d7b6d60728511527a1d5c090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fab043d7b6d60728511527a1d5c090">&#9670;&nbsp;</a></span>WaitAnyUpdateAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::WaitAnyUpdateAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates all generator nodes in the context to their latest available data, first waiting for any of the nodes to have new data available. </p>
<dl class="section note"><dt>Note</dt><dd>Typical applications use this method. Consider using this method for your application.</dd></dl>
<p><b>Remarks</b></p>
<p>This method requests from OpenNI to cause all nodes with new data available in the context's Production Graph to update their application buffers with the new data, each node updating its own application buffer.</p>
<p>Before OpenNI causes the data updates, it waits for any of the nodes to have notified that it has new data available. On receiving a 'new data available' notification, OpenNI then causes all nodes with new data available to update their application buffers with their new data. At this stage the generator nodes have "generated" new data. This method then stops waiting and returns a success status. The application can now read the newly generated data.</p>
<p>A node that does not have new data available does not update its application buffer.</p>
<p>An error situation is defined as: after a preset timeout, none of the nodes have yet notified OpenNI they have new data available. On error, the method stops waiting and returns an error status. None of the nodes update their application buffers.</p>
<p>See <a class="el" href="conc_updating_data.html#conc_updating_data__summary_of_wait_fns">'Wait and Update' Methods</a> for an overview to the <a class="el" href="conc_updating_data.html">'WaitXUpdateAll'</a> methods and how to read the data from the nodes.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">XN_STATUS_WAIT_DATA_TIMEOUT</td><td>No new data available within 2 seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae498b727aa0fdade75f91bdb2563f88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae498b727aa0fdade75f91bdb2563f88c">&#9670;&nbsp;</a></span>WaitNoneUpdateAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::WaitNoneUpdateAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immediately updates all generator nodes in the context to their latest available data, without waiting for notification that any node has new data available. </p>
<p><b>Remarks</b></p>
<p>This method requests from OpenNI to cause all nodes in the context's Production Graph with new data available to update their application buffers with the new data, each node updating its own application buffer.</p>
<p>OpenNI causes all nodes with new data available to update their application buffers with their new data. At this stage the generator nodes have "generated" new data. This method returns a success status. The application can now read the newly generated data.</p>
<p>A node that does not have new data available does not update its application buffer.</p>
<p>See <a class="el" href="conc_updating_data.html#conc_updating_data__summary_of_wait_fns">'Wait and Update' Methods</a> for an overview to the <a class="el" href="conc_updating_data.html">'WaitXUpdateAll'</a> methods and how to read the data from the nodes. </p>

</div>
</div>
<a id="ad4bab84f35a855639d485da99a05c585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bab84f35a855639d485da99a05c585">&#9670;&nbsp;</a></span>WaitOneUpdateAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::WaitOneUpdateAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates all generator nodes in the context to their latest available data, first waiting for a specified node to have new data available. </p>
<p><b>Remarks</b></p>
<p>This method requests from OpenNI to cause all nodes in the context's Production Graph with new data available to update their application buffers with the new data, each node updating its own application buffer.</p>
<p>Before OpenNI causes the data updates, it waits for a specified node to notify that it has new data available. On receiving the 'new data available' notification, OpenNI then causes all nodes with new data available to update their application buffers with their new data. At this stage the generator nodes have "generated" new data. This method then stops waiting and returns a success status. The application can now read the newly generated data.</p>
<p>A node that does not have new data available does not update its application buffer.</p>
<p>An error situation is defined as: after a preset timeout, none of the nodes have yet notified OpenNI they have has new data available. On error, the method stops waiting and returns an error status. None of the nodes update their application buffers.</p>
<p>See <a class="el" href="conc_updating_data.html#conc_updating_data__summary_of_wait_fns">'Wait and Update' Methods</a> for an overview to the <a class="el" href="conc_updating_data.html">'WaitXUpdateAll'</a> methods and how to read the data from the nodes.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">XN_STATUS_WAIT_DATA_TIMEOUT</td><td>No new data available within 2 seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_xn_cpp_wrapper_8h_source.html">XnCppWrapper.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 4 2019 12:14:06 for OpenNI 1.5.4 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
